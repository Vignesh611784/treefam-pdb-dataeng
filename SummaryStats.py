# -*- coding: utf-8 -*-
"""SummaryStatsFinal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yKHjlNpcLqtgmT4SBYHCqsXALUbUR52z
"""

#Import libraries
import numpy as np
import pandas as pd
from google.colab import drive

#Since I used google colab for this code, the next eight lines have to be changed
drive.mount('/content/drive/',force_remount=True)
!cp drive/My\ Drive/Colab\ Notebooks/'names.txt' .
!cp drive/My\ Drive/Colab\ Notebooks/'TF101001.aa.cleaned.fasta' .
!cp drive/My\ Drive/Colab\ Notebooks/'TF101002.aa.cleaned.fasta' .
!cp drive/My\ Drive/Colab\ Notebooks/'TF101003.aa.cleaned.fasta' .
!cp drive/My\ Drive/Colab\ Notebooks/'TF101004.aa.cleaned.fasta' .
!cp drive/My\ Drive/Colab\ Notebooks/'TF101005.aa.cleaned.fasta' .
!cp drive/My\ Drive/Colab\ Notebooks/'TF101001.phyloxml.xml' .
!cp drive/My\ Drive/Colab\ Notebooks/'pfam_hits.txt' .
!cp drive/My\ Drive/Colab\ Notebooks/'pdbmap-3' .

#Imports AlignIO from the Bio package to open the multiple sequence allignment file
!pip install Bio
from Bio import AlignIO
from Bio import SeqIO

#Opens the file names.txt in read mode
input = open('names.txt',mode = 'r')
#Opens the file, SUMMARY.txt, in write mode
outDataFile = open('SUMMARY.txt',mode = 'w')
outDataFile.write('SUMMARY STATISTICS')

#Returns the number of proteins in the data
def numProtein(data):
  return len(data)

#Returns the mean, median, standard deviation, max and min of the columns and rows as a tuple
def AlignmentStats(data):
  #Replaces '-' with Nan and removes the last column
  data.replace('-', np.nan, inplace=True)

  #Replace NaNs with 0s and other values with 1s
  binarydata = data.notna().astype(int)

  #Calculate the sum of each row and column
  row_sums = binarydata.sum(axis=1)
  column_sums = binarydata.sum(axis=0)

  var1 = stats(row_sums)
  var2 = stats(column_sums)
  return var1,var2

#Returns the mean, median, standard deviation, max and min of a dataset
def stats(dataset):
  numVal = np.array(dataset)
  meanVal = np.mean(numVal)
  medianVal = np.median(numVal)
  stdVal = np.std(numVal)
  maxVal = np.max(numVal)
  minVal = np.min(numVal)
  return meanVal,medianVal,stdVal,maxVal,minVal

#Prints the mean, median, standard deviation, max and min of a dataset
def printStats(var):
  outDataFile.write('     - Mean : ' + str(var[0])+'\n')
  outDataFile.write('     - Median : ' + str(var[1])+'\n')
  outDataFile.write('     - Standard Deviation : ' + str(var[2])+'\n')
  outDataFile.write('     - Max : ' + str(var[3])+'\n')
  outDataFile.write('     - Min : ' + str(var[4])+'\n')

from scipy.stats import entropy
#Finds the column Entropy from the dataFrame and finds the mean, median, standard deviation, max, min
def perColEntropy(data):
  valueCount = pd.DataFrame(data.apply(pd.Series.value_counts))
  valueCount.replace(np.nan,0,inplace=True)
  sums = valueCount.sum(axis=0)
  valueCount = valueCount.loc[:, sums != 0]
  num = entropy(valueCount,base=20)
  var = stats(num)
  outDataFile.write(' - Entropy Data\n')
  printStats(var)


numFamily = 0 #Keeps count of the number of families
#proteinRecord = [record.id for record in SeqIO.parse('TF101001.aa.fasta', "fasta")] #The protein names
#print(proteinRecord)
proteinval = [] #The number of proteins for each of the families
MSAval = [] #The MSA widths for each of the families
while True:
  #Reading each of the names of the files
  line = input.readline()
  if not line:
    break
  line = line.strip()
  outDataFile.write('\nFor family '+str(line))
  line = line + '.aa.cleaned.fasta'
  sequences = list(SeqIO.parse(line, "fasta")) #Gets the sequences for each of the protein families
  data = pd.DataFrame(sequences)
  val = AlignmentStats(data)
  proteinval.append(numProtein(data)) #Appends the number of proteins in the family to proteinval
  MSAval.append(val[0][3]) #Appends the MSA maximum width per family to proteinval
  numFamily = numFamily+1
  outDataFile.write('\n - Number of proteins: '+str(numProtein(data)))

  #Alignment statistics for the data in each family
  value = AlignmentStats(data)

  outDataFile.write('\n - Maximum width of MSA: '+ str(value[0][3]))
  outDataFile.write('\n - Alignment sizes \n')
  outDataFile.write('   - Rows\n')
  printStats(value[0])
  outDataFile.write('   - Columns\n')
  printStats(value[1])

  perColEntropy(data) #Gives entropy data for each family

#Returns the version of the tree used
def versionInfo(file_path):
  versionArr = None
  with open(file_path, 'r') as file:
    lines = file.readlines()
    for line in lines:
      if line.startswith('#') or line.startswith(';') or line.startswith('<'):
        if 'version' in line.lower():
          versionArr = line.strip()
  return versionArr.split('version="')[1].split('"')[0]

input.close()
#Prints the necessary details to the file
outDataFile.write('\n')
valuesInfo = versionInfo('TF101001.phyloxml.xml')
outDataFile.write('Version: '+str(valuesInfo))
outDataFile.write('\n\n')
outDataFile.write('Number of families: '+str(numFamily))
outDataFile.write('\n')
outDataFile.write(' - Protein Data per Family\n')
var = stats(proteinval)
printStats(var)
outDataFile.write(' - MSA Data per Family\n')
var = stats(MSAval)
printStats(var)
outDataFile.close()
!cp 'SUMMARY.txt' drive/My\ Drive/Colab\ Notebooks/

#Creates a mapping between PFam names and TreeFam names and stores it in a dictionary
dataVals = pd.read_csv('pfam_hits.txt', delim_whitespace=True, header=0)
dataVals.sort_values(by='seq_id').reset_index(drop=True)
dataVals = dataVals[dataVals.duplicated(subset='seq_id', keep='first') | ~dataVals.duplicated(subset='seq_id', keep=False)]
dataVals['hmm_acc'] = dataVals['hmm_acc'].str.split('.').str[0]
treeToPfam = dict(zip(dataVals['hmm_acc'], dataVals['seq_id']))

#Creates a mapping between PFam names and PDB names and stores it in a dictionary
dataVals = pd.read_csv('pdbmap-3', delim_whitespace=True, header=None)
dataVals[0] = dataVals[0].str.slice(0, -1)
dataVals[4] = dataVals[4].str.slice(0, -1)
pdbPfam = dict(zip(dataVals[4], dataVals[0]))

#Creates a pandas data frame from the treeToPfam dictionary and removes certain protein names that either start
#with g or are completely numeric. It also recreates the treeToPFam dictionary with the cleaned data.
treeToPfamData = pd.DataFrame([(k, v) for k, vals in treeToPfam.items() for v in vals], columns=['pfam', 'tfam'])
treeToPfamData = treeToPfamData.groupby('pfam')['tfam'].apply(lambda x: ' '.join(x)).reset_index()
treeToPfamData['tfam'] = treeToPfamData['tfam'].str.strip()
treeToPfamData = treeToPfamData[~treeToPfamData['tfam'].str[0].str.isnumeric()]
treeToPfamData = treeToPfamData[~treeToPfamData['tfam'].str.contains(':')]
treeToPfam = treeToPfamData.groupby('pfam')['tfam'].apply(list).to_dict()

#Creates a pandas data frame from the pdbPfam dictionary and removes certain protein names that either contain
#'E+' or are longer than 4 characters. It also recreates the treeToPFam dictionary with the cleaned data.
pdbPfamData = pd.DataFrame([(k, v) for k, vals in pdbPfam.items() for v in vals], columns=['pfam', 'pdb'])
pdbPfamData['pdb'] = pdbPfamData['pdb'].str.strip()
pdbPfamData = pdbPfamData.groupby('pfam')['pdb'].apply(lambda x: ' '.join(x)).reset_index()
pdbPfamData = pdbPfamData[~pdbPfamData['pdb'].str.contains('E+')]
pdbPfamData = pdbPfamData[pdbPfamData['pdb'].str.split().str.len() == 4]
pdbPfam = pdbPfamData.groupby('pfam')['pdb'].apply(list).to_dict()

#Creates a new dictionary with the common keys of both treeToPfam and pdbPfam. This new dictionary maps TreeFam data to
#PDB data. It prints this new dictionary to nameMappings.csv with the help of a pandas dataframe
commonpdb = set(treeToPfam.keys()).intersection(pdbPfam.keys())
linkedDictionary = {key: (''.join(treeToPfam[key][0].split()),''.join(pdbPfam[key][0].split())) for key in commonpdb}
vals = list(linkedDictionary.values())
dataNames = pd.DataFrame(vals, columns=['TreeFam Proteins', 'PDB names'])
dataNames.to_csv('nameMappings.csv', index=False)

#The line below this current line needs to be changed as I used google colab
!cp 'nameMappings.csv' drive/My\ Drive/Colab\ Notebooks/